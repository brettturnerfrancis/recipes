{"version":3,"sources":["mock/mockData.js","Recipe/Recipe.jsx","SearchResults/SearchResults.jsx","SearchEngine/SearchEngine.js","SearchField/SearchField.jsx","App.js","serviceWorker.js","index.js"],"names":["mockData","id","name","source","tags","location","Recipe","recipe","className","target","href","data-id","SearchResults","results","filtered","useState","filterText","setFilterText","recipes","map","result","key","useEffect","length","match","buildTextString","elasticlunr","require","SearchField","updateSearchTerms","searchTerms","setSearchTerms","onChange","value","placeholder","searchEngine","init","searchIndex","initSearchIndex","search","terms","replace","expand","documentStore","docs","ref","this","addField","setRef","forEach","addDoc","App","searchResults","setSearchResults","isFiltered","setIsFiltered","Boolean","window","hostname","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"qQAAaA,EAAW,CACpB,CACIC,GAAI,EACJC,KAAM,uBACNC,OAAQ,cACRC,KAAM,CACF,WAEJC,SAAU,iFAEd,CACIJ,GAAI,EACJC,KAAM,2BACNC,OAAQ,SACRC,KAAM,CACF,SAEJC,SAAU,qFAEd,CACIJ,GAAI,EACJC,KAAM,qBACNC,OAAQ,cACRC,KAAM,CACF,QACA,SAEJC,SAAU,gF,YCfHC,MATf,YAA2B,IAAVC,EAAS,EAATA,OACb,OACI,uBAAGC,UAAU,SAASC,OAAO,SAASC,KAAMH,EAAOF,UAC/C,yBAAKM,UAAQ,cAAcH,UAAU,gBAAgBD,EAAOL,MAC5D,yBAAKS,UAAQ,gBAAgBH,UAAU,kBAAkBD,EAAOJ,U,MC6B7DS,MAhCf,YAA+C,IAAtBC,EAAqB,EAArBA,QAASC,EAAY,EAAZA,SAAY,EACNC,qBADM,mBACnCC,EADmC,KACvBC,EADuB,KAGpCC,EAAUL,EAAQM,KAAI,SAAAC,GAAM,OAC9B,kBAAC,EAAD,CACIC,IAAKD,EAAOnB,GACZM,OAAQa,OAkBhB,OAJAE,qBAAU,WACNL,EAZoB,WACpB,IAAMC,EAA6B,IAAnBL,EAAQU,OAAe,SAAW,UAC9CC,EAA2B,IAAnBX,EAAQU,OAAe,UAAY,QAE/C,OAAIT,EACM,GAAN,OAAUD,EAAQU,OAAlB,YAA4BL,EAA5B,YAAuCM,EAAvC,gBAEM,GAAN,OAAUX,EAAQU,OAAlB,YAA4BL,EAA5B,cAKUO,MACf,CAACZ,EAASC,IAGT,oCACI,yBAAKH,UAAQ,eAAeH,UAAU,yBAAyBQ,GAC/D,6BAAME,K,OC/BZQ,EAAcC,EAAQ,I,MCuBbC,MApBf,YAA6C,IAAtBC,EAAqB,EAArBA,kBAAqB,EAEFd,mBAAS,IAFP,mBAEjCe,EAFiC,KAEpBC,EAFoB,KAaxC,OAJAT,qBAAU,WACNO,EAAkBC,KACnB,CAACA,IAGA,yBAAKtB,UAAU,gBACX,2BAAOA,UAAU,sBAAsBwB,SAX1B,SAAC,GAA2B,IAAfC,EAAc,EAAxBxB,OAAUwB,MAC9BF,EAAeE,GACfJ,EAAkBI,IASiDA,MAAOH,EAAaI,YAAY,mBCXrGC,EAAe,IFLrB,iDACIC,KAAO,SAAClB,GACJ,EAAKA,QAAUA,EACf,EAAKmB,YAAc,EAAKC,mBAHhC,KAMIC,OAAS,SAACC,GACN,OAAIA,EAAMC,QAAQ,MAAO,IAAIlB,OAClB,EAAKc,YAAYE,OAAOC,EAAO,CAACE,QAAQ,IAAOvB,KAAI,SAAAC,GACtD,OAAO,EAAKiB,YAAYM,cAAcC,KAAKxB,EAAOyB,QAG/C,EAAK3B,SAZxB,KAgBIoB,gBAAkB,WACd,IAAID,EAAcX,GAAY,WAC1BoB,KAAKC,SAAS,QACdD,KAAKC,SAAS,UACdD,KAAKC,SAAS,QACdD,KAAKE,OAAO,SAOhB,OAJA,EAAK9B,QAAQ+B,SAAQ,SAAA1C,GACjB8B,EAAYa,OAAO3C,MAGhB8B,IEDAc,MApBf,WAAgB,IAAD,EAC6BpC,mBAAS,IADtC,mBACNqC,EADM,KACSC,EADT,OAEuBtC,oBAAS,GAFhC,mBAENuC,EAFM,KAEMC,EAFN,KAWb,OAFApB,EAAaC,KAAKpC,GAGhB,yBAAKQ,UAAU,OACb,0CACA,kBAAC,EAAD,CAAaqB,kBAVU,SAACW,GAC1Ba,EAAiBlB,EAAaI,OAAOC,IACrCe,EAAcf,EAAMjB,OAAS,MAS3B,kBAAC,EAAD,CAAeV,QAASuC,EAAetC,SAAUwC,MCZnCE,QACW,cAA7BC,OAAOpD,SAASqD,UAEe,UAA7BD,OAAOpD,SAASqD,UAEhBD,OAAOpD,SAASqD,SAASlC,MACvB,2DCbNmC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,SD0HpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLC,QAAQD,MAAMA,EAAME,c","file":"static/js/main.daf5819f.chunk.js","sourcesContent":["export const mockData = [\n    {\n        id: 1,\n        name: 'Coffee Creme Caramel',\n        source: 'Bon Appetit',\n        tags: [\n            'dessert',\n        ],\n        location: 'https://brettturnerfrancis.github.io/recipes/mock-s3/coffee-creme-caramel.jpg'\n    },\n    {\n        id: 2,\n        name: 'Heirloom Tomato Focaccia',\n        source: 'FOOD52',\n        tags: [\n            'bread'\n        ],\n        location: 'https://brettturnerfrancis.github.io/recipes/mock-s3/heirloom-tomato-focaccia.pdf'\n    },\n    {\n        id: 3,\n        name: 'Soy-Marinated Eggs',\n        source: 'Bon Appetit',\n        tags: [\n            'asian',\n            'snack'\n        ],\n        location: 'https://brettturnerfrancis.github.io/recipes/mock-s3/soy-marinated-eggs.jpg'\n    }\n]\n","import React from 'react';\nimport './Recipe.css';\n\nfunction Recipe({recipe}) {\n    return (\n        <a className=\"recipe\" target=\"_blank\" href={recipe.location}>\n            <div data-id=\"recipe-name\" className=\"recipe__name\">{recipe.name}</div>\n            <div data-id=\"recipe-source\" className=\"recipe__source\">{recipe.source}</div>\n        </a>\n    )\n}\n\nexport default Recipe;\n","import React, { useState, useEffect } from 'react';\nimport Recipe from '../Recipe/Recipe';\nimport './SearchResults.css';\n\nfunction SearchResults({ results, filtered }) {\n    const [filterText, setFilterText] = useState();\n\n    const recipes = results.map(result =>\n        <Recipe\n            key={result.id}\n            recipe={result} />\n    );\n\n    const buildTextString = () => {\n        const recipes = results.length === 1 ? 'recipe' : 'recipes',\n            match = results.length === 1 ? 'matches' : 'match';\n\n        if (filtered) {\n            return `${results.length} ${recipes} ${match} your search`\n        } else {\n            return `${results.length} ${recipes} available`\n        }\n    }\n\n    useEffect(() => {\n        setFilterText(buildTextString())\n    }, [results, filtered])\n\n    return (\n        <>\n            <div data-id=\"result-count\" className=\"results__result-count\">{filterText}</div>\n            <div>{recipes}</div>\n        </>\n    )\n}\n\nexport default SearchResults;\n","const elasticlunr = require('elasticlunr');\n\nexport class RecipeSearch {\n    init = (recipes) => {\n        this.recipes = recipes;\n        this.searchIndex = this.initSearchIndex();\n    }\n\n    search = (terms) => {\n        if (terms.replace(/\\s/g, '').length) {\n            return this.searchIndex.search(terms, {expand: true}).map(result => {\n                return this.searchIndex.documentStore.docs[result.ref];\n            })\n        } else {\n            return this.recipes;\n        }\n    }\n\n    initSearchIndex = () => {\n        let searchIndex = elasticlunr(function() {\n            this.addField('name');\n            this.addField('source');\n            this.addField('tags');\n            this.setRef('id')\n        })\n\n        this.recipes.forEach(recipe => {\n            searchIndex.addDoc(recipe)\n        });\n\n        return searchIndex;\n    }\n}","import React, { useState, useEffect } from 'react';\nimport './SearchField.css';\n\nfunction SearchField({ updateSearchTerms }) {\n    // searchTerms state is not lifted to parent because a future update will incorporate a debounce\n    const [searchTerms, setSearchTerms] = useState('');\n\n    const handleChange = ({ target: { value } }) => {\n        setSearchTerms(value);\n        updateSearchTerms(value)\n    }\n\n    useEffect(() => {\n        updateSearchTerms(searchTerms)\n    }, [searchTerms])\n\n    return (\n        <div className=\"search-field\">\n            <input className=\"search-field__input\" onChange={handleChange} value={searchTerms} placeholder=\"find recipes\" />\n        </div>\n    )\n}\n\nexport default SearchField;","import React, { useState } from 'react';\nimport { mockData } from './mock/mockData';  //TODO: replace with live data\nimport './App.css';\nimport SearchResults from './SearchResults/SearchResults';\nimport { RecipeSearch } from './SearchEngine/SearchEngine';\nimport SearchField from './SearchField/SearchField';\n\nconst searchEngine = new RecipeSearch();\n\nfunction App() {\n  const [searchResults, setSearchResults] = useState([]);\n  const [isFiltered, setIsFiltered] = useState(false);\n\n  const onSearchTermChange = (terms) => {\n    setSearchResults(searchEngine.search(terms));\n    setIsFiltered(terms.length > 0)\n  }\n\n  searchEngine.init(mockData)\n\n  return (\n    <div className=\"App\">\n      <h1>My Recipes</h1>\n      <SearchField updateSearchTerms={onSearchTermChange} />\n      <SearchResults results={searchResults} filtered={isFiltered} />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}